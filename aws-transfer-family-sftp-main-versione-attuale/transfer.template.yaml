---
AWSTemplateFormatVersion: '2010-09-09'
Description: Provides a template for creating an AWS Transfer for SFTP service.
  The service use a lambda function for authentication endpoint as IdP.

Parameters:
  SubnetA:
    Description: The ID of the first public subnet where the transfer servers will be deployed in the Production VPC.
    Type: AWS::EC2::Subnet::Id
  SubnetB:
    Description: The ID of the second public subnet where the transfer servers will be deployed in the Production VPC.
    Type: AWS::EC2::Subnet::Id
  VPC:
    Description: ID of the Production VPC where the SFTPServer will be deployed.
    Type: AWS::EC2::VPC::Id

Resources:
  #Elastic IPs to be used for SFTP server. Two IPs used for HA
  EIPTran01:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
  EIPTran02:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  ##################
  #     LOGGING    #
  ##################
  ServerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: transferfamily-sftp-logs
      KmsKeyId: arn:aws:kms:eu-west-1:151425774723:key/a9c04dea-911c-4763-a361-e99cfee45268
      RetentionInDays: 30

  ####################
  #    SFT SERVER    #
  ####################
  TransferServer:
    Type : AWS::Transfer::Server
    Properties:
      EndpointDetails:
        AddressAllocationIds:
          - !GetAtt EIPTran01.AllocationId
          - !GetAtt EIPTran02.AllocationId
        SubnetIds:
          - !Ref SubnetA
          - !Ref SubnetB
        SecurityGroupIds:
             - !Ref TrSecurityGroup
        VpcId: !Ref VPC
      EndpointType: VPC
      IdentityProviderDetails: 
        Function: !GetAtt GetUserConfigLambda.Arn
        SftpAuthenticationMethods: PASSWORD
      IdentityProviderType: AWS_LAMBDA
      LoggingRole:
        Fn::GetAtt: TransferServerRole.Arn
      StructuredLogDestinations: 
        - !GetAtt ServerLogGroup.Arn
      Tags:
        - Key: Name
          Value: SFTPServer
        - Key: transfer:customHostname
          Value: sftp.dev.ego.energy #--> Domain gestisto sull'account DevPartner
  
  TransferServerRole:
      Type: "AWS::IAM::Role"
      Properties:
        RoleName: sftp-server-role
        AssumeRolePolicyDocument:
          Statement:
            - Effect: Allow
              Principal:
                Service:
                - transfer.amazonaws.com
              Action:
                - "sts:AssumeRole"
        Policies:
          - PolicyName: cw-logGroup-write
            PolicyDocument:
              Statement:
              - Effect: "Allow"
                Action:
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: !Sub "${ServerLogGroup.Arn}:*"
  
  TrSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow Internet connection to SFTPServer
      GroupName: ego-sftp-sg
      VpcId: !Ref VPC
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 22
        ToPort: 22
        CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
      - CidrIp: 0.0.0.0/0
        IpProtocol: "-1"
      Tags:
      - Key: Name
        Value: ego-sftp-sg

  ################
  #    LAMBDA    #
  ################

  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: sftp-server-auth-lambda-logs
      KmsKeyId: arn:aws:kms:eu-west-1:151425774723:key/a9c04dea-911c-4763-a361-e99cfee45268
      RetentionInDays: 30

  GetUserConfigLambda:
    Type: AWS::Lambda::Function
    Properties:
      KmsKeyArn: arn:aws:kms:eu-west-1:151425774723:key/f9f5cfbb-2ff1-4a2e-be43-b9d304e0b535
      LoggingConfig:
        LogGroup: !Ref LambdaLogGroup
      Code:
        ZipFile:
          Fn::Sub: |
            import os
            import json
            import boto3
            import base64
            from botocore.exceptions import ClientError

            def lambda_handler(event, context):
                resp_data = {}
                print(event)

                if 'username' not in event or 'serverId' not in event:
                    print("Incoming username or serverId missing  - Unexpected")
                    return response_data

                # It is recommended to verify server ID against some value, this template does not verify server ID
                input_username = event['username']
                print("Username: {}, ServerId: {}".format(input_username, event['serverId']));

                if 'password' in event:
                    input_password = event['password']
                else:
                    print("No password, checking for SSH public key")
                    input_password = ''

                # Lookup user's secret which can contain the password or SSH public keys
                resp = get_secret("SFTP/" + input_username)

                if resp != None:
                    resp_dict = json.loads(resp)
                else:
                    print("Secrets Manager exception thrown")
                    return {}

                if input_password != '':
                    if 'Password' in resp_dict:
                        resp_password = resp_dict['Password']
                    else:
                        print("Unable to authenticate user - No field match in Secret for password")
                        return {}

                    if resp_password != input_password:
                        print("Unable to authenticate user - Incoming password does not match stored")
                        return {}
                else:
                    # SSH Public Key Auth Flow - The incoming password was empty so we are trying ssh auth and need to return the public key data if we have it
                    if 'PublicKey' in resp_dict:
                        resp_data['PublicKeys'] = [resp_dict['PublicKey']]
                    else:
                        print("Unable to authenticate user - No public keys found")
                        return {}

                # If we've got this far then we've either authenticated the user by password or we're using SSH public key auth and
                # we've begun constructing the data response. Check for each key value pair.
                # These are required so set to empty string if missing
                if 'Role' in resp_dict:
                    resp_data['Role'] = resp_dict['Role']
                else:
                    print("No field match for role - Set empty string in response")
                    resp_data['Role'] = ''

                # These are optional so ignore if not present
                if 'Policy' in resp_dict:
                    resp_data['Policy'] = resp_dict['Policy']

                if 'HomeDirectoryDetails' in resp_dict:
                    print("HomeDirectoryDetails found - Applying setting for virtual folders")
                    resp_data['HomeDirectoryDetails'] = resp_dict['HomeDirectoryDetails']
                    resp_data['HomeDirectoryType'] = "LOGICAL"
                elif 'HomeDirectory' in resp_dict:
                    print("HomeDirectory found - Cannot be used with HomeDirectoryDetails")
                    resp_data['HomeDirectory'] = resp_dict['HomeDirectory']
                else:
                    print("HomeDirectory not found - Defaulting to /")

                print("Completed Response Data: "+json.dumps(resp_data))
                return resp_data

            def get_secret(id):
                region = os.environ['SecretsManagerRegion']
                print("Secrets Manager Region: "+region)

                client = boto3.session.Session().client(service_name='secretsmanager', region_name=region)

                try:
                    resp = client.get_secret_value(SecretId=id)
                    # Decrypts secret using the associated KMS CMK.
                    # Depending on whether the secret is a string or binary, one of these fields will be populated.
                    if 'SecretString' in resp:
                        print("Found Secret String")
                        return resp['SecretString']
                    else:
                        print("Found Binary Secret")
                        return base64.b64decode(resp['SecretBinary'])
                except ClientError as err:
                    print('Error Talking to SecretsManager: ' + err.response['Error']['Code'] + ', Message: ' + str(err))
                    return None
      Description: A function to lookup and return user data from AWS Secrets Manager.
      Handler: index.lambda_handler
      Role:
        Fn::GetAtt: LambdaExecutionRole.Arn
      Runtime: python3.12
      Environment:
        Variables:
          SecretsManagerRegion: !Ref AWS::Region

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
      - PolicyName: LambdaSecretsPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - secretsmanager:GetSecretValue
            Resource:
              Fn::Sub: arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:SFTP/*

  GetUserConfigLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName:
        Fn::GetAtt: GetUserConfigLambda.Arn
      Action: lambda:InvokeFunction
      Principal: transfer.amazonaws.com

Outputs:
  ServerId:
    Value:
      Fn::GetAtt: TransferServer.ServerId
  ServerEndpoint:
    Value:
      Fn::Join:
      - ''
      - - Fn::GetAtt: TransferServer.ServerId
        - .server.transfer.
        - Ref: AWS::Region
        - .amazonaws.com
